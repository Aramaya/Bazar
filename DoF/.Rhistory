reward
reward = sample(data[which(data[-base.weapon,"Type"] == "Récompense"),],4*n)
reward = sample(data[which(data[-base.weapon,"Type"] == "Récompense"),],4*n,replace = TRUE)
reward
data[-base.weapon,"Type"]
which(data[-base.weapon,"Type"] == "Récompense")
data[which(data[-base.weapon,"Type"] == "Récompense"),]
reward = sample(data[which(data[-base.weapon,"Type"] == "Récompense"),],4*n)
n = 1# Number of player
weapon = sample(data[which(str_detect(raw,"W")),])
base.weapon = weapon[1:2]# Base weapon
donjon = sample(data[which(data$Type == "Rencontre"),],3*n)
reward = sample(data[which(data[-base.weapon,"Type"] == "Récompense"),],4*n)
4*n
data[which(data[-base.weapon,"Type"] == "Récompense"),]
which(data[-base.weapon,"Type"] == "Récompense")
data[-base.weapon,"Type"]
data[-base.weapon,"Type"]
-base.weapon
data[!=base.weapon,"Type"]
data[base.weapon,"Type"]
base.weapon
base.weapon = weapon[1:2]# Base weapon
base.weapon
weapon[1:2]
weapon
data[which(str_detect(raw,"W")),]
weapon = data[sample(which(str_detect(raw,"W"))),]
base.weapon = weapon[1:2]# Base weapon
base.weapon
data[sample(which(str_detect(raw,"W"))),]
base.weapon = weapon[1:2,]# Base weapon
base.weapon
base.weapon = weapon[1:2,1]# Base weapon
weapon = data[sample(which(str_detect(raw,"W"))),]
base.weapon = weapon[1:2,1]# Base weapon
donjon = sample(data[which(data$Type == "Rencontre"),1],3*n)
reward = sample(data[which(data[base.weapon,"Type"] == "Récompense"),1],4*n)
base.weapon
data[-base.weapon,"Type"]
sample(which(str_detect(raw,"W")))
weapon = data[w.sample[2],]
w.sample = sample(which(str_detect(raw,"W")))
weapon = data[w.sample[2],]
weapon
weapons = data[w.sample[1:2],]
weapons
##### Settings
n = 1# Number of player
w.sample = sample(which(str_detect(raw,"W")))
weapons = data[w.sample[1:2],1]
donjon = sample(data[which(data$Type == "Rencontre"),1],3*n)
reward = sample(data[which(data[-w.sample[1:2],"Type"] == "Récompense"),1],4*n)
hord = sample(which(data$Type == "Horde"),1)
boss = sample(which(data$Type == "Boss"),1)
imc = function(taille,poids) poids/taille^2
imc(1.65,51.5)
imc(1.65,50.5)
mu = 2500 ; phi = 1.0
kappa = 1/phi ; lambda = 1/(phi*mu)
pgamma (2700 , kappa , lambda )-pgamma (2300 , kappa , lambda )
# Data
flandre = c(25,69,65,106,80,106,136,94,76,46)
wallonie = c(17,36,47,58,47,53,59,54,33,21)
freq = as.matrix(rbind(flandre,wallonie))
row.names(freq) = c("Flanders","Wallonia")
colnames(freq) = c("< 1200","[1200 ; 1500]","[1500 ; 1800]","[1800 ; 2300]","[2300 ; 2700]",
"[2700 ; 3300]","[3300 ; 4000]","[4000 ; 4900]","[4900 ; 6000]","6000+")
# Function
lpost = function(theta = c(3000,1),freq) {# Work only for 1 region at a time
n = sum(freq)# get n
cat = c(-Inf,1200,1500,1800,2300,2700,3300,4000,4900,6000,Inf)
kappa = 1/theta[2]# define kappa from theta
lambda = 1/(theta[2]*theta[1])# define lambda from theta
##### Prior
l.prior.phi = dunif(theta[2],max = 10,log = TRUE)
l.prior.mu = dnorm(theta[1],3000,300,log = TRUE)
##### Likelihood
all.proba = sapply(1:(length(cat)-1),function(i) pgamma(cat[i+1],kappa,lambda) - pgamma(cat[i],kappa,lambda))
#likelihood = dmultinom(freq,prob = all.proba,log = TRUE)
likelihood = sum(vec*log(all.proba)) + sum(log(1:n)) + sum(sapply(1:length(vec),function(i) -sum(log(1:vec[i]))))
##### Return post
logpost = l.prior.mu+l.prior.phi+likelihood# combine all value
return(logpost)# return results
}
##### 4
credible = function(freq) {
lp = laplace(lpost,c(3000,1),freq)
mu = lp$mode[1]# mode
sd = sqrt(lp$var[1,1])# variance
return(mu+c(-1,1)*1.96*sd)
}
credible(freq[1,])# Flanders
laplace(lpost,c(3000,1),freq[1,])
require(LearnBayes)
laplace(lpost,c(3000,1),freq[1,])
laplace(lpost,c(3000,1),freq = freq[1,])
require(LearnBayes)
# Data
flandre = c(25,69,65,106,80,106,136,94,76,46)
wallonie = c(17,36,47,58,47,53,59,54,33,21)
freq = as.matrix(rbind(flandre,wallonie))
row.names(freq) = c("Flanders","Wallonia")
colnames(freq) = c("< 1200","[1200 ; 1500]","[1500 ; 1800]","[1800 ; 2300]","[2300 ; 2700]",
"[2700 ; 3300]","[3300 ; 4000]","[4000 ; 4900]","[4900 ; 6000]","6000+")
# Function
lpost = function(theta = c(3000,1),freq) {# Work only for 1 region at a time
n = sum(freq)# get n
cat = c(-Inf,1200,1500,1800,2300,2700,3300,4000,4900,6000,Inf)
kappa = 1/theta[2]# define kappa from theta
lambda = 1/(theta[2]*theta[1])# define lambda from theta
##### Prior
l.prior.phi = dunif(theta[2],max = 10,log = TRUE)
l.prior.mu = dnorm(theta[1],3000,300,log = TRUE)
##### Likelihood
all.proba = sapply(1:(length(cat)-1),function(i) pgamma(cat[i+1],kappa,lambda) - pgamma(cat[i],kappa,lambda))
#likelihood = dmultinom(freq,prob = all.proba,log = TRUE)
likelihood = sum(freq*log(all.proba)) + sum(log(1:n)) + sum(sapply(1:length(vec),function(i) -sum(log(1:vec[i]))))
##### Return post
logpost = l.prior.mu+l.prior.phi+likelihood# combine all value
return(logpost)# return results
}
##### 4
credible = function(freq) {
lp = laplace(lpost,c(3000,1),freq = freq[1,])
mu = lp$mode[1]# mode
sd = sqrt(lp$var[1,1])# variance
return(mu+c(-1,1)*1.96*sd)
}
credible(freq[1,])# Flanders
laplace(lpost,c(3000,1),freq = freq[1,])
lpost = function(theta = c(3000,1),freq) {# Work only for 1 region at a time
n = sum(freq)# get n
cat = c(-Inf,1200,1500,1800,2300,2700,3300,4000,4900,6000,Inf)
kappa = 1/theta[2]# define kappa from theta
lambda = 1/(theta[2]*theta[1])# define lambda from theta
##### Prior
l.prior.phi = dunif(theta[2],max = 10,log = TRUE)
l.prior.mu = dnorm(theta[1],3000,300,log = TRUE)
##### Likelihood
all.proba = sapply(1:(length(cat)-1),function(i) pgamma(cat[i+1],kappa,lambda) - pgamma(cat[i],kappa,lambda))
#likelihood = dmultinom(freq,prob = all.proba,log = TRUE)
likelihood = sum(freq*log(all.proba)) + sum(log(1:n)) + sum(sapply(1:length(freq),function(i) -sum(log(1:freq[i]))))
##### Return post
logpost = l.prior.mu+l.prior.phi+likelihood# combine all value
return(logpost)# return results
}
credible = function(freq) {
lp = laplace(lpost,c(3000,1),freq = freq[1,])
mu = lp$mode[1]# mode
sd = sqrt(lp$var[1,1])# variance
return(mu+c(-1,1)*1.96*sd)
}
credible(freq[1,])# Flanders
laplace(lpost,c(3000,1),freq = freq[1,])
credible = function(freq) {
lp = laplace(lpost,c(3000,1),freq)
mu = lp$mode[1]# mode
sd = sqrt(lp$var[1,1])# variance
return(mu+c(-1,1)*1.96*sd)
}
credible(freq[1,])# Flanders
min(c(rpois(1),1))
min(c(rpois(1,5),1))
min(c(rpois(1,5),1))
min(c(rpois(1,5),1))
min(c(rpois(1,5),1))
min(c(rpois(1,5),1))
max(c(rpois(1,5),1))
max(c(rpois(1,5),1))
max(c(rpois(1,5),1))
max(c(rpois(1,5),1))
max(c(rpois(1,5),1))
max(c(rpois(1,5),1))
max(c(rpois(1,5),1))
max(c(rpois(1,5),1))
max(c(rpois(1,5),1))
max(c(rpois(1,5),1))
max(c(rpois(1,5),1))
max(c(rpois(1,5),1))
max(c(rpois(5,5),1))
max(c(rpois(5,5),1))
max(c(rpois(5,5),1))
max(c(rpois(5,5),1))
sapply(5,function(i) max(c(rpois())))
is.na(c(1,2,NA))
is.na(c(1,2,NA)) | c(1,2,NA) == 2
rpois(5,0.1)
rpois(5,0.5)
rpois(5,0.5)
rpois(5,0.5)
rpois(5,0.5)
rpois(5,10)
rpois(5,10)
rpois(5,10)
rpois(5,0.001)
rpois(5,0.001)
rpois(5,0.001)
rpois(5,0.001)
rpois(5,0.001)
rpois(5,0.001)
rpois(5,0.001)
rpois(5,0.001)
rpois(5,0.001)
rpois(5,0.001)
rpois(5,0.001)
rpois(5,0)
rpois(5,0)
rpois(5,0)
rpois(5,0)
rpois(5,0)
rpois(5,0)
rpois(5,0)
rpois(5,0)
rpois(5,0)
rpois(5,0.001)
rpois(5,0.001)
rpois(5,0.001)
rpois(5,NaN)
rpois(5,Inf)
rpois(5,-Inf)
1/0
max(c(NA,2),na.rm = TRUE)
max(c(NA,2),na.rm = TRUE)
max(c(NA,0),na.rm = TRUE)
deltaTime = max(c(1/sum(vecLambda),0),na.rm = TRUE)
vecLambda = 0
vecLambda = 0
deltaTime = max(c(1/sum(vecLambda),0),na.rm = TRUE)
deltaTime = max(c(1/sum(vecLambda),0),na.rm = TRUE)
rpois(5,-5)
rpois(5,max(c(-5,0)))
?pareto
??pareto
library(mnormt)
library(coda)
w_i<-c(1.6907,1.7242,1.7552,1.7842,1.8113,1.8369,1.8610,1.8839)
y_i<-c(6,13,18,28,52,53,61,60)
n_i<-c(59,60,62,56,63,59,62,60)
obj<-glm(cbind(y_i,n_i-y_i)~w_i,family="binomial")
summary(obj)
alpha_hat<-coef(obj)[1]
beta_hat<-coef(obj)[2]
wdom <- seq(1.6,2,length=200)
pihat <- exp(alpha_hat + beta_hat * wdom)/(1+exp(alpha_hat + beta_hat*wdom))
plot(wdom, pihat, ylab="Death prob of insect", xlab ="w (gas)", type="l")
Sigma_hat<-vcov(obj)
lpost<-function(theta){
# theta[1] = alpha ; \theta[2] = beta
eta<-theta[1]+theta[2]*w_i
pi<-exp(eta)/(1+exp(eta))
return(sum(dbinom(y_i,n_i,pi,log=TRUE)))
}
lpost(c(alpha_hat, beta_hat))
M <- 21000
burnin <- 1000
theta <- array(dim=c(2,M))
theta[,1] <- c(alpha_hat, beta_hat)
theta[, 1:5]
n_accept<-0
sd_prop<-2.4
for (i in 2:M){
theta_prop <- theta[,i-1] + rmnorm(1,c(0,0),sd_prop^2*Sigma_hat)
prob <- min(1,exp(lpost(theta_prop)-lpost(theta[,i-1])))
accept <- (runif(1)<=prob)
if (accept){
theta[,i] <- theta_prop
n_accept <- n_accept + 1
} else {
theta[,i] <- theta[,i-1]
}
}
theta = theta[,-c(1:burnin)]
rownames(theta) <- c("alpha", "beta")
accept_rate <- paste0(round(n_accept/(M-1),digits=2)*100,"%")
cat("Acceptance rate : ",accept_rate,"\n")
summary(t(theta))
par(mfrow=c(2,2))
traceplot(as.mcmc(t(theta)))
densplot(as.mcmc(t(theta)), col="blue")
HPDbeta <- HPDinterval(as.mcmc(t(theta)))[2,]
CIbeta <- quantile(theta[2,], probs = c(0.025,0.975))
HPDbeta
CIbeta
abline(v=c(HPDbeta[1], HPDbeta[2]), col="red")
abline(v=c(CIbeta[1], CIbeta[2]), col="green")
par(mfrow=c(1,2))
#Histogram of generated samples for alpha and beta
hist(theta[1,],main="alpha")
hist(theta[2,],main="beta")
as.mcmc(t(theta))
theta
sqrt(3000)
sqrt(10)
i = 1
i = sapply(2:10,function(i) (i[-1])+2)
i
i = 1:2
(i[-1])+2
i = sapply(2:10,function(i) (i[-1])+2)
i
i = sapply(2:10,function(i) (test(i[-1]))
)
i = 1:2
test = function(a) a+2
i = sapply(2:10,function(i) test(i[-1]))
i
i = c()
i[1] = 1
test = function(a) a+2
test(i[1])
vec  = c()
vec  = c()
vec[1] = 1
test = function(a) a+2
test(vec[1])
vec = sapply(2:10,function(i) test(vec[-i]))
vec
sapply(2:10,function(i) test(vec[-i]))
vec  = c()
vec[1] = 1
test = function(a) a+2
sapply(2:10,function(i) test(vec[-i]))
sapply(2:10,function(i) test(test(vec[-i])))
sapply(2:10,function(i) test(test(vec[-i])))
sapply(2:10,function(i) test(test(vec[-i])))
vec = sapply(2:10,function(i) vec[i] = test(vec[i-1]))
sapply(2:10,function(i) vec[i] = test(vec[i-1]))
test(vec[(i-1)])
sapply(2:10,function(i) vec[i] = test(vec[(i-1)]))
vec  = rep(0,10)
vec[1] = 1
test = function(a) a+2
vec = sapply(2:10,function(i) vec[i] = test(vec[(i-1)]))
vec
vec = sapply(2:10,function(i) {
a = test(vec[(i-1)])
return(test(a))
})
vec  = rep(0,10)
vec[1] = 1
test = function(a) a+2
vec = sapply(2:10,function(i) {
a = test(vec[(i-1)])
return(test(a))
})
vec  = rep(0,10)
vec = sapply(2:10,function(i) {
a = test(vec[(i-1)])
return(test(a))
})
vec  = rep(0,10)
vec[1] = 1
vec  = rep(0,10)
vec[1] = 1
vec = sapply(2:10,function(i) {
a = test(vec[(i-1)])
return(test(a))
})
vec  = rep(0,10)
vec[1] = 1
vec[2:10] = sapply(2:10,function(i) {
a = test(vec[(i-1)])
return(test(a))
})
vec  = rep(0,10)
vec[1] = 1
vec[2:10] = sapply(2:10,function(i) {
a = test(vec[(i-1)])
return(test(a))
})
test.test = function(a) {
test(test(a))
}
test.test = function(a) {
test(test(a))
}
test = function(a) a+2
vec  = rep(0,10)
vec[1] = 1
vec[2:10] = sapply(2:10,function(i) test.test(vec[i]))
test.test = function(a) {
test(a[i-1])
}
test = function(a) a+2
vec  = rep(0,10)
vec[1] = 1
vec[2:10] = sapply(2:10,function(i) test.test(vec[i]))
vec
vec  = rep(0,10)
vec[1] = 1
vec[2:10] = sapply(2:10,function(i) test.test(vec[i]))
test.test = function(a) {
a[i-1] = test(a)
return(a[i-1])
}
vec  = rep(0,10)
vec[1] = 1
vec[2:10] = sapply(2:10,function(i) test.test(vec[i]))
vec  = rep(0,10)
vec[1] = 1
vec[2:10] = sapply(vec,function(i) test.test(vec[i]))
sapply(vec,function(i) test.test(vec[i]))
dat = as.matrix(cbind(1:5,2:6))
sapply(dat, function(x) x/c(NA,head(x,-1)) - 1 )
sapply(dat, function(x) x/c(NA,head(x,-1)) - 1)
dat = as.matrix(cbind(1:5,2:6))
dat
sapply(dat, function(x) x/c(NA,head(x,-1)) - 1)
sapply(dat, function(x) df/rbind(c(NA,NA), df[-nrow(df),]) - 1)
dat/rbind(c(NA,NA), dat[-nrow(dat),]) - 1
dat = as.matrix(cbind(1:5,2:6))
Reduce(test,vec,accumulate = TRUE)
test = function(x) x+2
test = function(x) x+2
vec = rep(0,10)
vec[1] = 1
Reduce(test,vec,accumulate = TRUE)
?Reduce(test,vec,accumulate = TRUE)
Reduce(f = test,x = vec,accumulate = TRUE)
Reduce(f = test,x = as.list(vec),accumulate = TRUE)
as.list(vec)
Reduce(f = test,x = as.list(vec),accumulate = TRUE)
Reduce(f = test,x = as.list(vec))
##define your function that takes two parameters
##these are the 'previous' and the 'current' elements
runSum <- function(sum, x){
res = 0
if (x == 1){
res = sum + 1
}
else if (x == 0 & sum < 5){
res = 0
}
else{
res = sum
}
res
}
#lets look at the absent values from subject B
x = c(1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1)
Reduce(x=x, f=runSum, accumulate=T)
# [1] 1 2 0 1 2 3 4 0 1 2 3 4 5 5 5 6 7
?Reduce()
test(vec)
sapply(2:10,test(vec[[i-1]]))
str_detect(raw,"1.png")
knitr::opts_chunk$set(echo = TRUE)
path = "pictures/"
raw = list.files(path)
require(stringr)
require(knitr)
type = c("bonus",
"Boss",
"encounter",
"horde",
"item",
"mob",
"W"
)
str_detect(raw,"1.png")
str_detect(raw,"*.png")
str_detect(raw,"*0.png")
str_detect(raw,".png")
str_detect(raw,"^.png")
str_detect(raw,'^.png')
require(data.table)
raw[Name %like% "^1.png"]
data[Nom %like% "^1.png"]
data["Nom" %like% "^1.png",1]
knitr::opts_chunk$set(echo = TRUE)
path = "pictures/"
raw = list.files(path)
require(stringr)
require(knitr)
type = c("bonus",
"Boss",
"encounter",
"horde",
"item",
"mob",
"W"
)
str_detect(raw,'^.png')
data = as.data.frame(cbind(raw,rep("",length(raw)),rep(0,length(raw))))
colnames(data) = c("Nom","Type","Quantité")
data$Type[c(which(str_detect(raw,"encounter")),
which(str_detect(raw,"mob")))] = "Rencontre"
data$Type[c(which(str_detect(raw,"bonus")),
which(str_detect(raw,"item")),
which(str_detect(raw,"W")))] = "Récompense"
data$Type[which(str_detect(raw,"Boss"))] = "Boss"
data$Type[which(str_detect(raw,"horde"))] = "Horde"
regexpr(";png",data$Nom)
grep(";png",data$Nom)
grep(".png",data$Nom)
??grep(".png",data$Nom)
?grep(".png",data$Nom)
?grep(".png",data$Nom)
p3 = 0.25
p = .25^3
p
p*100
inc = .0002
s = 0.01
s+inc*2
s*3+inc*2
s*3+inc*2
p2 = s*3+inc*2
p*p2
p*p2*100
p
